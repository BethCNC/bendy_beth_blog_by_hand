---
alwaysApply: true
---
A Comprehensive Guide to Implementing a Design Token Architecture with Figma, Tokens Studio, and Style Dictionary

Design tokens represent the critical link in modern design-to-development workflows, serving as the atomic units of a design system that bridge the gap between visual language and code. This guide provides a detailed, end-to-end methodology for establishing a robust token architecture. We will walk through the entire process, from the initial strategic design decisions in Figma to the generation of a developer-ready JSON file compatible with powerful build tools like Style Dictionary and frameworks like Tailwind CSS. The ultimate goal is to create a single source of truth that not only ensures consistency across platforms but also enhances collaboration, simplifies maintenance, and scales effectively with your product.


--------------------------------------------------------------------------------


1. Foundational Principles of Token Architecture

Before launching into tooling and implementation, it is strategically vital to establish a clear philosophy for your token architecture. The true "source of truth" is not the JSON file itself, but the underlying design decisions it represents. A well-architected system captures not just the what but also the why, ensuring that the logic behind your design language is as durable as the code it generates.

1.1. The "Why" Behind the "What"

Design tokens are excellent at describing what a design decision is—for example, that a primary button color is a specific shade of blue. However, they often fail to capture why that decision was made. To create a resilient and understandable system, it is crucial to complement your tokens with an Architecture Decision Record (ADR). An ADR is a living document that chronicles the reasoning behind key choices, such as naming conventions, hierarchical structures, and component API decisions. This context is invaluable for future team members, AI assistants, and even your future self when revisiting past work.

An ADR captures this rationale. Below is a completed ADR template entry for the decision to avoid hierarchical terms like "primary" in favor of descriptive ones. This makes the concept immediately tangible.

1.2. Architecture is Custom, Not Copied

A token architecture is like an expensive suit; it must be custom-tailored to your organization's specific brand, team workflow, and product requirements. There is a common misconception that one can simply copy a reference structure from another successful design system. However, the real value of a token architecture lies in its ability to solve your unique problems. A copied system will inevitably fail because it wasn't designed to accommodate your legacy code and adapt to your team's specific constraints. A custom-built system may require more upfront effort, but it will deliver a perfect fit that maximizes value and ensures long-term scalability.

1.3. The Visual Verification Loop

Design tokens are a form of logic, but design itself is a visual discipline. Therefore, a critical principle of any token architecture is the "visual verification loop." This is the iterative process where tokens are defined in a logical structure and then immediately applied and tested on real design examples within a tool like Figma. As humans, we are far better at understanding things visually. No product is ever tested by reading its code; it is tested by interacting with its interface. This loop ensures that the token logic accurately reflects the intended brand decisions and user experience before it ever reaches development.

With these foundational principles in mind, we can move to the first practical step: preparing a well-organized design environment in Figma.


--------------------------------------------------------------------------------


2. Preparing Your Figma Design System

A robust and well-structured design system is the necessary foundation for any successful token implementation. Before a single token is created, core visual elements like typography, color, and icons must be systematized, and a library of reusable components must be established. This preparatory work ensures that your tokens have a consistent and logical framework to govern.

2.1. Establishing Core Styles

Systematizing the foundational elements of your brand's visual identity is the first step. This involves creating a clear, accessible, and scalable system for typography and color within Figma.

* Typography:
  * Define Text Styles: Begin by defining a comprehensive set of text styles that cover all use cases, from large headings to small captions. Assign appropriate font sizes, weights, line heights, and letter spacing to each style.
  * Create a Hierarchy: Establish a clear typographic hierarchy (e.g., Heading-1, Heading-2, Body-Text, Caption) to guide users through content and create a consistent visual rhythm.
  * Use Consistent Naming Conventions: Name your text styles clearly and predictably (e.g., H1-Primary, Body-Text) so they can be easily identified and applied by the entire team.
* Color:
  * Create a Color Palette: Define your brand’s primary, secondary, and accent colors, along with a full range of neutrals (grays, whites). Ensure these colors align with your brand's identity and are organized logically.
  * Set Up Color Styles: In Figma, create color styles for each color in your palette. Use descriptive names (e.g., Primary-Blue, Neutral-Gray-500) to make them easily discoverable.
  * Check for Accessibility: Ensure your color palette meets accessibility standards, particularly for contrast ratios between text and background colors. Use plugins to verify that your designs are usable for everyone.

2.2. Creating and Managing Icons

Icons are a critical part of a modern design system, providing visual cues that enhance usability and communication. Establishing a consistent icon library is a key prerequisite for a token-based system. This involves creating a cohesive set of icons that align with your brand's visual language, using similar stroke widths, corner radii, and proportions. Once designed, these icons should be converted into Figma components, organized by category, and managed with variants for different states (e.g., filled vs. outlined) to keep the library tidy and easy to navigate.

2.3. Building the Component Library

Components are the reusable building blocks of your design system. They ensure that your visual language is applied consistently across all products and platforms, from buttons and inputs to complex data tables. Figma’s advanced features work in tandem with design tokens to make these components both powerful and flexible.

* Component Properties: These are essential for controlling the changeable aspects of a component, allowing you to create flexible designs while maintaining system-wide consistency.
  * Boolean Properties: Function as true/false toggles that control the visibility of a layer within a component. This is perfect for showing or hiding an icon in a button, which reduces the need for multiple variants.
  * Instance Swap Properties: Allow designers to swap predefined instances within a component. This is ideal for changing an icon in an icon button without detaching the main component.
  * Text Properties: Enable the editing of text strings directly from the properties panel while preserving the component's underlying structure and style.

With a well-organized foundation of styles, icons, and components, your Figma file is now prepared. This groundwork sets the stage for the next logical step: creating a structured and scalable naming convention for the tokens that will govern this system.


--------------------------------------------------------------------------------


3. Designing a Scalable Token Naming Convention

An effective naming convention is not a minor detail—it is a critical, strategic foundation for a successful token system. A token's name serves as a shared language between design and development, communicating its precise purpose and intended usage. A well-designed schema directly impacts the system's scalability, maintainability, and team-wide adoption.

3.1. The Anatomy of a Token Name

A robust token name is constructed from a series of hierarchical levels, which can be organized into four primary "Level Groups." This structure provides clarity and predictability.

Level Group	Description
Namespace	The company, product, or team using the design system (e.g., Salesforce, IBM Carbon).
Object	The target UI element the token applies to, such as a component, group of components, or a smaller element.
Base	The foundation of the schema, defining the token's core nature (Category, Concept, and Property).
Modifier	Refines the token by specifying variants, states, scales, or modes (e.g., hover, large, dark).

3.2. Detailed Naming Levels

These four groups are composed of up to 13 individual levels, allowing for highly specific and descriptive token names. While not every token will use every level, this comprehensive structure provides a scalable framework.

1. System: The design system the token belongs to (e.g., cdr for REI Cedar).
2. Theme: A style variation for different products or brands within a single system.
3. Domain: Design requirements for different teams across a company (e.g., marketing vs. product).
4. Group: A collection of related components, such as Form or Menu.
5. Component: A foundational UI element, such as a Button, Input, or Tooltip.
6. Element: A granular, atomic part of a component, like an Icon or Handle.
7. Category: The fundamental type of token, such as Color, Font, Space, or Size.
8. Concept: A high-level descriptor of purpose, such as Alert, Interactive, or Status.
9. Property: The specific attribute being styled, like Background, Font Size, or Border Width.
10. Variant: A variation of a design element, such as Primary, Secondary, or Success.
11. State: Defines styles for interactive states like Default, Hover, Focus, and Disabled.
12. Scale: Predefined measurements for scalable properties like XXS, XL, 1x, or 4x.
13. Mode: Adapts styles for different environmental conditions, such as light and dark.

3.3. Hierarchy and Specificity

Tokens are typically organized into a three-tiered hierarchy that moves from abstract to specific. This structure promotes reusability and maintainability.

* Core: The raw, foundational values of your design system. They have no contextual meaning and simply store a primitive value, such as a hex code (#8b5cf6) or a pixel value (16px).
* Semantic (Alias): These tokens recodify core values with context-based meaning. Instead of referencing a raw color like red-500, a semantic token would describe its purpose, such as color-feedback-error. This abstraction allows for easier updates and theming.
* Component: This is the most specific level, tying a token directly to a part of a particular component. For example, button-cancel-background-color would define the background color for a very specific button variant.

A common best practice is to start simple by working primarily at the semantic level. Only add component-level tokens when a specific override or unique need arises that cannot be addressed by the more general semantic tokens.

Now that we have established a clear theory for naming our tokens, we can move to the practical application of building them using the Tokens Studio plugin.


--------------------------------------------------------------------------------


4. Building Your Token Structure in Tokens Studio

Tokens Studio is a powerful Figma plugin that excels at creating and managing design tokens, especially for complex, multi-themed systems. It serves as the central hub for defining the logic that underpins your design system. This section details a recommended hierarchical approach for structuring token sets within the plugin to ensure clarity, maintainability, and a smooth export process.

4.1. The Hierarchical Set Structure

Organizing your tokens into a logical hierarchy of sets is crucial for managing complexity. This approach separates foundational values from their application, creating helpful guardrails for designers.

* Core tokens: These are the foundational building blocks of your system. They contain the raw primitive values (e.g., a specific hex code or pixel size) and are used as reference points for other tokens. Core tokens should not be surfaced in final designs or applied directly to components.
* Theme tokens: These are subsets of core tokens that create distinct groupings for various uses. For example, you might create separate themes for different brands, products, or marketing initiatives, each pulling from the same core set but applying them differently.
* Modes: These are "semantic buckets" that define styles for dynamic elements. The most common use is for light and dark themes, but they can also manage styles for different surfaces (e.g., surface-primary, surface-secondary), content states (rest, active), and interaction states (hover, focus).
* Applied tokens: These are the tokens that designers will apply directly to components in Figma. They can be defined at either the semantic or component level. These tokens reference the core, theme, and mode tokens, creating a clear separation between the underlying architecture and its practical application.

The primary benefit of this structure is maintaining a clean separation between reference tokens and applied tokens. This simplifies the design workflow, reduces the risk of misapplication, and makes the entire system easier to manage and scale.

4.2. Creating and Managing Tokens

The process of creating a token in Tokens Studio is straightforward.

1. Open the New Token Modal: Click the + icon to open the "New Token" modal for the desired token type (e.g., Color, Sizing, Spacing).
2. Define Name and Value: Enter a unique Name for the token following your established naming convention. Input the Value, which can be a raw value (like #FFFFFF), a mathematical expression ({spacing.small} * 2), or a reference to another token.
3. Edit or Duplicate: To modify an existing token, right-click on it and select "Edit Token" or "Duplicate Token" from the context menu.

4.3. Defining Themes

Themes in Tokens Studio allow you to control which token sets are active at any given time, making it easy to switch between contexts like different brands or color modes. To configure themes, use the "Manage themes" option from the theme dropdown at the top of the plugin. In the theme management view, you can create a new theme and customize it by selecting which token sets are active. This is where you designate your core sets as 'source' (making them available for reference only) and enable your 'applied' sets (making them visible and usable in your Figma designs), using the controls for each set in the theme configuration panel.

With your token sets created and your themes defined, the next logical step is to apply this newly created system to your components within the Figma file.


--------------------------------------------------------------------------------


5. Applying and Syncing Tokens in Figma

Once your tokens are structured in Tokens Studio, the next critical step is to apply them to your Figma components and synchronize them with Figma's native features like styles and variables. This process makes the token system tangible and usable for the entire design team, transforming abstract values into a concrete design system that can be published and shared.

5.1. Methods for Applying Tokens to Components

There are four primary methods for linking tokens from the plugin to your components.

* Method 1: Applying with Tokens Studio: This is a direct approach where you select a component layer in Figma, find the corresponding token in the plugin, and click the "Apply to selection" button.
* Method 2: Applying with Figma Variables: You first export your token sets from Tokens Studio as Figma Variables. Then, you select a component layer and apply the variable via the "styles and variables" library icon in Figma's design panel.
* Method 3: Applying with Figma Styles: Similar to variables, you can export tokens as Figma Styles. However, this method has limitations, as each mode (e.g., light, dark) must be exported separately.
* Method 4: Applying with Figma Styles with Variable References: This is an advanced option where you enable "Create styles with variable references" during export, which creates a connection between the exported styles and variables.

Due to stability and workflow issues with Figma Styles, the clear recommendation is to use either the direct Tokens Studio method (Method 1) or the Figma Variables method (Method 2).

5.2. Understanding the Workflow Differences

The two recommended approaches create different workflows with distinct advantages. Choosing the right one depends on your team's needs for control versus flexibility.

Applying with Tokens Studio	Applying with Figma Variables
This method is Tokens Studio-driven. Control is centralized within the plugin, creating a stable and authoritative connection. If a designer makes a local override in Figma, reloading the tokens from the plugin will revert the change, ensuring the design system remains the single source of truth.	This method is Figma-driven. It gives downstream designers more flexibility and control within the familiar Figma interface. Changes made directly to the applied variables in Figma will sync back to Tokens Studio, allowing for a more collaborative, two-way workflow.

5.3. Exporting to Figma and Publishing

To make your tokens available to the rest of the team as a library, you need to export them and publish the changes.

1. Use the "Styles & variables" menu in Tokens Studio and select "Export styles & variables."
2. Choose which tokens and sets you want to export. It's crucial not to export your reference (core) tokens to avoid misapplication by other designers.
3. Be aware of the terminology mapping between the two tools:
  * Tokens Studio "sets" correspond to Figma "groups."
  * Tokens Studio "themes" correspond to Figma "modes."
  * Tokens Studio "theme groups" correspond to Figma "collections."
4. Once the export is complete, open the Library menu in Figma (from the Assets panel) and publish your changes. This will make all the new styles and variables available to any file connected to your design system library.

After successfully applying and publishing your tokens within the design environment, the final bridge to cross is exporting them for developer handoff.


--------------------------------------------------------------------------------


6. Exporting and Syncing for Developer Handoff

Moving design tokens from the design tool into a version-controlled environment like a code repository is a pivotal moment in the design-to-development pipeline. This step transforms the design system from a visual guide into a definitive, machine-readable source of truth that developers can programmatically consume. This process forms the crucial bridge between design and code.

6.1. Connecting Tokens Studio to a Repository

Tokens Studio can sync your token sets directly to an external source, with GitHub being the recommended method due to its robust version control capabilities. This allows design decisions and code to live in the same location.

The setup process involves a few key steps:

1. Generate a Personal Access Token: In your GitHub Developer Settings, generate a new Personal Access Token. It is critical that this token is given the repo scope to allow it to read and write to your repositories.
2. Configure Tokens Studio: Navigate to the "Settings" tab in the Tokens Studio plugin. Select GitHub as a new sync provider and input your credentials: the newly generated Access Token, the repository path (e.g., owner/repo), the branch name you want to sync with, and the file path for the output JSON (e.g., /tokens/tokens.json). Before making your first push, ensure the repository has been initialized with a README file to prevent errors.
3. Push and Pull: Once configured, push and pull icons will appear at the bottom of the plugin. When you have changes to sync, click the push icon. You will be prompted to write a commit message that describes the changes for your team's reference.
4. Create a Pull Request: After a successful push, the plugin will prompt you to create a pull request. This action redirects you to GitHub, where you can notify developers of the changes and initiate a formal code review process before the new token values are merged into the main branch.

6.2. The JSON Output File(s)

The result of this synchronization process is one or more .json files committed to your repository. A practical question that often arises is whether to use a single, all-encompassing JSON file or to split tokens into multiple files.

* One common approach is to export a single tokens.json file that contains all token tiers (global, alias, component). This can simplify the CI/CD pipeline, as developers can point their build tools to a single tokens.json file that serves as the definitive source.
* Another valid approach is to export multiple files, often one for each tier (e.g., global.json, alias.json, component.json). This can offer more organizational clarity.

Ultimately, this is not a decision for designers to make in a vacuum. The key takeaway is to discuss this with your development team to determine which method is more comfortable and efficient for their specific workflow and build tools.

With a raw JSON file now residing in a version-controlled repository, the next and final step is to transform that data into platform-specific code.


--------------------------------------------------------------------------------


7. Transforming Tokens with Style Dictionary

Style Dictionary is a robust build engine that serves as the final link in the design token pipeline. It takes the platform-agnostic design tokens from your JSON file and transforms them into platform-specific code that developers can use directly in their projects. Whether you need CSS custom properties for the web, Swift code for iOS, or XML for Android, Style Dictionary is the key to making a single source of truth usable across any development environment.

7.1. The Style Dictionary Workflow

Using Style Dictionary follows a straightforward, four-step process:

1. Preparation: The primary prerequisite is having your design tokens organized in a JSON format within your code repository.
2. Installation: Install Style Dictionary into your project using NPM. In your terminal, run the command: npm install style-dictionary
3. Configuration: Create a configuration file (e.g., config.json or style-dictionary.config.js). In this file, you define the source (the path to your input token JSON files) and the platforms (the desired outputs, specifying transforms and file formats).
4. Transformation: Run the build process from your terminal. This command instructs Style Dictionary to read your source tokens, apply the configured transformations, and generate the output files: npx style-dictionary build

7.2. Integrating with Tokens Studio Exports

The JSON files exported from Tokens Studio have a specific structure and contain special token types (like boxShadow or typography) that require custom processing. To handle this, Tokens Studio provides an official package of transforms designed to work seamlessly with Style Dictionary.

The @tokens-studio/sd-transforms package includes a collection of transformations that correctly parse Tokens Studio's output. Some key functions include:

* Mapping token descriptions to code comments for better developer context.
* Resolving mathematical expressions within token values.
* Automatically converting unitless dimension tokens to px values.
* Transforming font weights from names (e.g., "Bold") to their corresponding numeric values (e.g., 700).
* Correctly expanding composite boxShadow tokens, mapping Tokens Studio's x and y properties to CSS-compatible offsetX and offsetY.
* Converting innerShadow token types to CSS-compatible inset values.

7.3. Handling Themes

Style Dictionary, in combination with the @tokens-studio/sd-transforms package, can effectively handle the themes you defined in Tokens Studio (e.g., light/dark modes).

* The recommended approach is to use the $themes.json file that Tokens Studio exports alongside your token sets. This file contains the definitions of your themes. You can write a simple script that reads this file and programmatically generates a separate configuration and output file for each theme (e.g., vars-light.css and vars-dark.css).
* For more complex, multi-dimensional theming (e.g., combining brand and mode), the package provides a permutateThemes function. This utility creates all possible theme combinations (e.g., light_casual, dark_casual, light_business), allowing you to generate a standalone file for every unique permutation.

This transformation process provides developers with ready-to-use code, but integrating these outputs with specific frontend frameworks like Tailwind CSS requires one final step.


--------------------------------------------------------------------------------


8. Integrating with Tailwind CSS

A common challenge arises when integrating a semantic, token-based design system with a "utility-first" framework like Tailwind CSS. At first glance, the two philosophies can seem contradictory. However, Tailwind is fully customizable and can be configured to work seamlessly with a robust design token architecture, bridging the gap between semantic design intent and utility-class implementation.

8.1. The "Utility-First" Challenge

The core conflict emerges from how designers and developers approach styling. Designers think in semantic terms, creating tokens that describe purpose and context (e.g., button-brand-tier1-hover-bg-color). In contrast, Tailwind's default class names are primitives that describe a specific visual property (e.g., bg-blue-500). This can lead to a disconnect where developers feel "trapped in primitives land," unable to translate the design system's semantic language into their workflow.

It is crucial to understand that "utility-first" does not mean "utility-only." Engineers are not restricted to using only the primitive class names provided out of the box.

8.2. The Solution: tailwind.config.js

The key to bridging this gap lies within the tailwind.config.js file. This configuration file is where the power of Tailwind's customizability is unlocked. It allows developers to extend Tailwind's default theme, defining custom class names that can be mapped directly to the semantic design token values generated by Style Dictionary.

For example, a developer can use the config file to map a semantic class like bg-button-brand-strong directly to the CSS variable --button-brand-tier1-hover-bg-color generated by Style Dictionary. This makes the design system's language native to the development environment, allowing engineers to use intuitive, design-system-aligned classes in their markup.

8.3. Fostering Collaboration

Successfully integrating tokens with Tailwind requires informed conversations and close collaboration between designers and engineers. Designers should understand the fundamentals of Tailwind's utility-first approach, while engineers should be aware of the benefits of semantic naming and the customization capabilities of their tools. The goal is to create a shared workflow where the tailwind.config.js file becomes the living implementation of the design system's token structure. This collaboration allows the entire team to move from "primitives land" into "semantic territory," where design and code speak the same language.


--------------------------------------------------------------------------------


Conclusion

This comprehensive guide has charted a course from high-level architectural principles to the granular details of implementation. By following this structured workflow—establishing foundational principles, preparing Figma, designing a scalable naming convention, building with Tokens Studio, syncing to a repository, transforming with Style Dictionary, and integrating with developer tools—teams can create a truly unified design-to-development pipeline. The result is a scalable, consistent design system powered by a clear and maintainable single source of truth. This approach fosters a highly efficient and collaborative environment between design and development. While the tools outlined here are powerful, remember that the most critical skill remains the ability to think through problems, make informed decisions, and architect a system that fits the unique context of your team and product.
